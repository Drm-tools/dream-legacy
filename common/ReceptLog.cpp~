/******************************************************************************\
 * Technische Universitaet Darmstadt, Institut fuer Nachrichtentechnik
 * Copyright (c) 2007
 *
 * Author(s):
 *	Volker Fischer, Andrew Murphy
 *
 * Description:
 *	see ReceptLog.h
 *
 ******************************************************************************
 *
 * This program is free software(), you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation(), either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY(), without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program(), if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
\******************************************************************************/

#include "Version.h"
#include "ReceptLog.h"
#include <iomanip>
#include <iostream>

/* implementation --------------------------------------------- */

void
CReceptLog::Start(const string & filename)
{
	cout << "CReceptLog::Start(" << filename << ")" << endl;
	File.open(filename.c_str(), ios::app);
	bHeaderWritten = FALSE;
	if(File.is_open())
		bLogActivated = TRUE;
}

void
CReceptLog::Stop()
{
	cout << "CReceptLog::Stop()" << endl;
	if(!bLogActivated)
		return;
	writeTrailer();
	File.close();
	bLogActivated = FALSE;
}

void
CReceptLog::Update()
{
	cout << "CReceptLog::Update()" << endl;
	if(!bLogActivated)
		return;
	if (bHeaderWritten == FALSE)
	{
		writeHeader();
		bHeaderWritten = TRUE;
	}
	writeParameters();
}

/* Get robustness mode string */
char CReceptLog::GetRobModeStr()
{
	char chRobMode = 'X';
	switch (Parameters.GetWaveMode())
	{
	case RM_ROBUSTNESS_MODE_A:
		chRobMode = 'A';
		break;

	case RM_ROBUSTNESS_MODE_B:
		chRobMode = 'B';
		break;

	case RM_ROBUSTNESS_MODE_C:
		chRobMode = 'C';
		break;

	case RM_ROBUSTNESS_MODE_D:
		chRobMode = 'D';
		break;

	case RM_NO_MODE_DETECTED:
		chRobMode = 'X';
		break;
	}
	return chRobMode;
}

void
CShortLog::writeHeader()
{
	cout << "CShortLog::writeHeader()" << endl;
	string latitude, longitude, label, SpecOcc, RobMode;
	_REAL bitrate = 0.0;

	Parameters.Lock();

	int iFrequency = Parameters.GetFrequency();
	const CGPSData & GPSData = Parameters.GPSData;
	if (GPSData.GetPositionAvailable())
	{
		GPSData.GetLatLongDegrees(latitude, longitude);
	}
	int iCurSelServ = Parameters.GetCurSelAudioService();

	if (Parameters.Service[iCurSelServ].IsActive())
	{
		/* Service label (UTF-8 encoded string -> convert ? TODO locale) */
		label = Parameters.Service[iCurSelServ].strLabel;
		bitrate = Parameters.GetBitRateKbps(iCurSelServ, FALSE);
		RobMode = GetRobModeStr();
		SpecOcc = GetSpecOccStr();
	}

	Parameters.Unlock();

	/* Beginning of new table (similar to standard DRM log file) */
	File << endl << ">>>>" << endl << "Dream" << endl
		 << "Software Version " << dream_version << endl;

	File << "Starttime (UTC)  " << strdate() << endl;

	File << "Frequency        ";
	if (iFrequency != 0)
		File << iFrequency << " kHz";
	File << endl;

	if (latitude!="")
	{
		File << "Latitude         " << latitude << endl;
		File << "Longitude        " << longitude << endl;
	}

	/* Write additional text */

	/* First get current selected audio service */

	/* Check whether service parameters were not transmitted yet */
	if (RobMode != "")
	{
		/* Service label (UTF-8 encoded string -> convert ? TODO locale) */
		File << "Label            " << label << endl;
		File << "Bitrate          " << bitrate << " kbps" << endl;
		File << "Mode             " << RobMode << endl;
		File << "Bandwidth        " 
	switch (SpecOcc)
	{
	case SO_0:
		File << "4,5 kHz";
		break;

	case SO_1:
		File << "5 kHz";
		break;

	case SO_2:
		File << "9 kHz";
		break;

	case SO_3:
		File << "10 kHz";
		break;

	case SO_4:
		File << "18 kHz";
		break;

	case SO_5:
		File << "20 kHz";
		break;

	default:
		File << "10 kHz";
	}
	File << endl;
	}

	File << "MINUTE  SNR     SYNC    AUDIO     TYPE";
	if(bRxlEnabled)
		File << "      RXL";
	File << endl;
}

void
CShortLog::writeParameters()
{
	cout << "CShortLog::writeParameters()" << endl;
	Parameters.Lock();

	int iAverageSNR = (int)Round(Parameters.SNRstat.getMean());
	int iNumCRCOkFAC = Parameters.ReceiveStatus.FAC.GetOKCount();
	int iNumCRCOkMSC = Parameters.ReceiveStatus.Audio.GetOKCount();

	int iTmpNumAAC;

	/* If no sync, do not print number of AAC frames. If the number
	   of correct FAC CRCs is lower than 10%, we assume that
	   receiver is not synchronized */
	if (iNumCRCOkFAC < 15)
		iTmpNumAAC = 0;
	else
		iTmpNumAAC = Parameters.iNumAudioFrames;

	Parameters.Unlock();

	try
	{
		File << "  " << iCount << "   " << iAverageSNR << iNumCRCOkFAC
			 << iNumCRCOkMSC << "/" << iTmpNumAAC << "        0";
		if (bRxlEnabled)
		{
			File << "      " << Round(Parameters.SigStrstat.getMean());
		}
		File << endl;
		File.flush();
	}
	catch(...)
	{
		/* To prevent errors if user views the file during reception */
	}
	iCount++;
}

void
CShortLog::writeTrailer()
{
	cout << "CShortLog::writeTrailer" << endl;

	_REAL rMaxSNR, rMinSNR;
	_REAL rMaxSigStr, rMinSigStr;

	Parameters.Lock();
	Parameters.SNRstat.getMinMax(rMaxSNR, rMinSNR);
	if (bRxlEnabled)
	{
		Parameters.SigStrstat.getMinMax(rMaxSigStr, rMinSigStr);
	}
	Parameters.Unlock();

	File << "SNR min: " << rMinSNR << ", max: " << rMaxSNR << endl;

	if (bRxlEnabled)
	{
		File << "RXL min: " << rMinSigStr << ", max: " << rMaxSigStr << endl;
	}

	/* Short log file ending */
	File << "CRC: " << endl << "<<<<" << endl << endl;
}

void
CLongLog::writeHeader()
{
	cout << "CLongLog::writeHeader" << endl;

	File << "FREQ/MODE/QAM PL:ABH,       DATE,       TIME,    SNR, SYNC, FAC, MSC, AUDIO, AUDIOOK, DOPPLER, DELAY";
	if (bRxlEnabled)
			File << ",     RXL";
	if (bPositionEnabled)
			File << ",     LATITUDE,    LONGITUDE";
#ifdef _DEBUG_
	/* In case of debug mode, use more parameters */
	File << ",    DC-FREQ, SAMRATEOFFS";
#endif
	File << endl;
}

void
CLongLog::writeParameters()
{
	cout << "CLongLog::writeParameters" << endl;

	Parameters.Lock();

	/* Get parameters for delay and Doppler. In case the receiver is
	   not synchronized, set parameters to zero */
	_REAL rDelay = (_REAL) 0.0;
	_REAL rDoppler = (_REAL) 0.0;
	if (Parameters.eAcquiState == AS_WITH_SIGNAL)
	{
		rDelay = Parameters.rMinDelay;
		rDoppler = Parameters.rSigmaEstimate;
	}

	/* Only show mode if FAC CRC was ok */
	int iCurProtLevPartA = 0;
	int iCurProtLevPartB = 0;
	int iCurProtLevPartH = 0;
	int iCurMSCSc = 0;

	if (Parameters.ReceiveStatus.FAC.GetStatus() == RX_OK)
	{
		/* Copy protection levels */
		iCurProtLevPartA = Parameters.MSCPrLe.iPartA;
		iCurProtLevPartB = Parameters.MSCPrLe.iPartB;
		iCurProtLevPartH = Parameters.MSCPrLe.iHierarch;
		switch(Parameters.eMSCCodingScheme)
		{
		case CS_3_SM:
			iCurMSCSc = 0;
			break;

		case CS_3_HMMIX:
			iCurMSCSc = 1;
			break;

		case CS_3_HMSYM:
			iCurMSCSc = 2;
			break;

		case CS_2_SM:
			iCurMSCSc = 3;
			break;

		case CS_1_SM:/* TODO */
			break;
		}
	}

	int iFrequency = Parameters.GetFrequency();
	char cRobMode = GetRobModeStr();

	_REAL rSNR = Parameters.SNRstat.getCurrent();
	ETypeRxStatus eFrameSyncStatus = Parameters.ReceiveStatus.FSync.GetStatus();
	ETypeRxStatus eFACStatus = Parameters.ReceiveStatus.FAC.GetStatus();
	ETypeRxStatus eAudioStatus = Parameters.ReceiveStatus.Audio.GetStatus();
	int iNumCRCMSC = Parameters.ReceiveStatus.Audio.GetCount();
	int iNumCRCOkMSC = Parameters.ReceiveStatus.Audio.GetOKCount();

	Parameters.Unlock();

	try
	{
		File << " " << iFrequency << cRobMode << iCurMSCSc
			 << iCurProtLevPartA << iCurProtLevPartB << iCurProtLevPartH
			 << strdate() 
			 << rSNR
			 << int(eFrameSyncStatus) << int(eFACStatus) << int(eAudioStatus)
			 << iNumCRCMSC << iNumCRCOkMSC << rDoppler << rDelay;

		if (bRxlEnabled)
			File << ",   " << Parameters.SigStrstat.getCurrent();

		if (bPositionEnabled)
		{
			double latitude, longitude;
			Parameters.GPSData.GetLatLongDegrees(latitude, longitude);
			File << ",   " << latitude << ",   " << longitude;
		}
#ifdef _DEBUG_
		/* Some more parameters in debug mode */
		File <<  Parameters.GetDCFrequency() << ", " << Parameters.GetSampFreqEst();
#endif
		File << endl;
		File.flush();
	}

	catch(...)
	{
		/* To prevent errors if user views the file during reception */
	}

}

void
CLongLog::writeTrailer()
{
	cout << "CLongLog::writeTrailer" << endl;
	File << endl << endl;
}

string
CReceptLog::strdate()
{
	time_t now;
	struct tm *today;
	(void) time(&now);
	stringstream s;

	today = gmtime(&now);		/* Always UTC */

	s << setw(4) << setfill('0')
	  << today->tm_year + 1900 << "-" << setw(2) << today->tm_mon + 1 << "-" << today->tm_mday
	  << " " << today->tm_hour << ":" << today->tm_min << ":" << today->tm_sec;
	return s.str();
}
